# Reversing is Amazing

x86_64 ELF Binary that checks flag

## Code Summary

It's not hard to analyze.

```c
// many variable declare here
chk_enc = [0x6f, 0x86, 0xE4, ...];
bptr = (void *)0x1100;
qmemcpy(keyd, bptr, 608uLL);
BIO* key = BIO_new_mem_buf(keyd, 608LL);
EVP_PKEY *pkey = NULL;
pkey = d2i_PrivateKey_bio(key, &pkey);
RSA *rsa = EVP_PKEY_get1_RSA(pkey);
RSA_private_encrypt(sizeof(argv[1]), argv[1], enc, rsa, 1);
if(!memcmp(enc, chk_enc))
	puts("Correct");
```

## Solution

We need to get private RSA key from bptr.

Key format is  PKCS#8 by documentation of d2i_PrivateKey_bio.

```
n=122473281967438489245200697284209085987870862283159865766870179887073743162940196687790020000214348808748860823908604767044897851166168164492210236033531220345674450723507633030168013139661432069654897358471472862044385693485920354874587842549791152511954498099227284018784968830037098759971168868584379278973
e=65537
d=2453689049288901481284595198653684634665523935758257224955377057108622988127935032898489345869988555867483318763324504617696123999895918335875490790118962772788267975404616215003567318542749505541245283789972104245436631066590804205899786231892408189084142342323127022150997354777517353740726754727419175645
p=11393754993065226486087954843624013976990664741228722251741843071861404833125574170749653965728825968751533731312043212421315432633015552231771862766316907
q=10749158819193625904838108987219123331434925729500850971466025243390183782175803041395805549143801745505370651512226364692495522855072594101358282259942839
u=7662813136086677851793672945783937298369868373437182150568129535271026873249501747984366002895393872301360029033684103106416274201513852021063402674734478
```

And the data we need to decrypt(chk_enc).

```
c=0x6f86e49629be8a5e21e2c0da25b795e05f0a6ce944db124c3a6c1487c6366b6d95061c2d119ef872cc9b748773a752720c5b928d7ca935ebc5d61e1c9e7ed36e433593d06c26b495e59928635eebad40ce2667f732b2030d302493843a19ac6f11bb0b5b418d9d491ab121d97943bc831c3698b95a53d9f4a3993467a28bce06
```

Code say that it gets private key(d2i_PrivateKey_bio) and encrypt(RSA_private_encrypt) with it. So, we have to decrypt with the public key.

```python
from Crypto.Util.number import long_to_bytes

c=0x6f86e49629be8a5e21e2c0da25b795e05f0a6ce944db124c3a6c1487c6366b6d95061c2d119ef872cc9b748773a752720c5b928d7ca935ebc5d61e1c9e7ed36e433593d06c26b495e59928635eebad40ce2667f732b2030d302493843a19ac6f11bb0b5b418d9d491ab121d97943bc831c3698b95a53d9f4a3993467a28bce06
n=122473281967438489245200697284209085987870862283159865766870179887073743162940196687790020000214348808748860823908604767044897851166168164492210236033531220345674450723507633030168013139661432069654897358471472862044385693485920354874587842549791152511954498099227284018784968830037098759971168868584379278973
e=65537

print(long_to_bytes(pow(c, e, n)).split(b'\x00')[1])  # split \xFF thing
```

And this will print flag.

```
TWCTF{Rivest_Shamir_Adleman}
```

