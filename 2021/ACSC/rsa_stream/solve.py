import gmpy2
from Crypto.Util.number import long_to_bytes, bytes_to_long, getStrongPrime, inverse
from Crypto.Util.Padding import pad

f1 = open("chal.py","rb").read()
f2 = open("chal.enc","rb").read()

n = 30004084769852356813752671105440339608383648259855991408799224369989221653141334011858388637782175392790629156827256797420595802457583565986882788667881921499468599322171673433298609987641468458633972069634856384101309327514278697390639738321868622386439249269795058985584353709739777081110979765232599757976759602245965314332404529910828253037394397471102918877473504943490285635862702543408002577628022054766664695619542702081689509713681170425764579507127909155563775027797744930354455708003402706090094588522963730499563711811899945647475596034599946875728770617584380135377604299815872040514361551864698426189453
e = 65537

tu = []

for a in range(0,len(f1),256):
  q = f1[a:a+256]
  q = bytes_to_long(q)
  p = f2[a:a+256]
  p = bytes_to_long(p)

  c = p ^ q
  tu.append((e, c))
  e = gmpy2.next_prime(e)


def dr(a, b):
    q, r = divmod(a, b)
    if r == 0:
        return (0, b)
    else:
        x, y = dr(b, r)
        return (y, x - q * y)

a, b = dr(tu[0][0], tu[1][0])

t1 = pow(tu[0][1], a, n)
t2 = pow(tu[1][1], b, n)
t = (t1 * t2) % n

print(unpad(long_to_bytes(t, 256), 256))
